import {
  HDNode,
  decryptJsonWallet,
  decryptJsonWalletSync,
  defaultPath,
  encrypt,
  entropyToMnemonic,
  init_lib3 as init_lib14,
  init_lib4 as init_lib16
} from "./chunk-4QA5VFOA.js";
import {
  Provider,
  Signer,
  SigningKey,
  TypedDataEncoder,
  computeAddress,
  defineReadOnly,
  getAddress,
  hashMessage,
  init_lib as init_lib4,
  init_lib10,
  init_lib11,
  init_lib12,
  init_lib14 as init_lib13,
  init_lib15,
  init_lib2 as init_lib5,
  init_lib4 as init_lib6,
  init_lib6 as init_lib7,
  init_lib8,
  init_lib9,
  keccak256,
  randomBytes,
  recoverAddress,
  resolveProperties,
  serialize,
  sha256,
  toUtf8Bytes
} from "./chunk-JQ3ASX3F.js";
import {
  BigNumber,
  Logger,
  arrayify,
  concat,
  formatFixed,
  hexDataSlice,
  hexlify,
  init_lib,
  init_lib2,
  init_lib3,
  isHexString,
  joinSignature,
  parseFixed,
  zeroPad
} from "./chunk-ALPDSS66.js";
import {
  __esm,
  __export
} from "./chunk-FJLWZCXQ.js";

// ../../node_modules/ethers/node_modules/@ethersproject/wallet/lib.esm/_version.js
var version;
var init_version = __esm({
  "../../node_modules/ethers/node_modules/@ethersproject/wallet/lib.esm/_version.js"() {
    version = "wallet/5.7.0";
  }
});

// ../../node_modules/ethers/node_modules/@ethersproject/wallet/lib.esm/index.js
var lib_exports = {};
__export(lib_exports, {
  Wallet: () => Wallet,
  verifyMessage: () => verifyMessage,
  verifyTypedData: () => verifyTypedData
});
function isAccount(value) {
  return value != null && isHexString(value.privateKey, 32) && value.address != null;
}
function hasMnemonic(value) {
  const mnemonic = value.mnemonic;
  return mnemonic && mnemonic.phrase;
}
function verifyMessage(message, signature) {
  return recoverAddress(hashMessage(message), signature);
}
function verifyTypedData(domain, types, value, signature) {
  return recoverAddress(TypedDataEncoder.hash(domain, types, value), signature);
}
var __awaiter, logger, Wallet;
var init_lib17 = __esm({
  "../../node_modules/ethers/node_modules/@ethersproject/wallet/lib.esm/index.js"() {
    "use strict";
    init_lib6();
    init_lib9();
    init_lib10();
    init_lib2();
    init_lib8();
    init_lib14();
    init_lib5();
    init_lib4();
    init_lib15();
    init_lib11();
    init_lib16();
    init_lib12();
    init_lib();
    init_version();
    __awaiter = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    logger = new Logger(version);
    Wallet = class extends Signer {
      constructor(privateKey, provider) {
        super();
        if (isAccount(privateKey)) {
          const signingKey = new SigningKey(privateKey.privateKey);
          defineReadOnly(this, "_signingKey", () => signingKey);
          defineReadOnly(this, "address", computeAddress(this.publicKey));
          if (this.address !== getAddress(privateKey.address)) {
            logger.throwArgumentError("privateKey/address mismatch", "privateKey", "[REDACTED]");
          }
          if (hasMnemonic(privateKey)) {
            const srcMnemonic = privateKey.mnemonic;
            defineReadOnly(this, "_mnemonic", () => ({
              phrase: srcMnemonic.phrase,
              path: srcMnemonic.path || defaultPath,
              locale: srcMnemonic.locale || "en"
            }));
            const mnemonic = this.mnemonic;
            const node = HDNode.fromMnemonic(mnemonic.phrase, null, mnemonic.locale).derivePath(mnemonic.path);
            if (computeAddress(node.privateKey) !== this.address) {
              logger.throwArgumentError("mnemonic/address mismatch", "privateKey", "[REDACTED]");
            }
          } else {
            defineReadOnly(this, "_mnemonic", () => null);
          }
        } else {
          if (SigningKey.isSigningKey(privateKey)) {
            if (privateKey.curve !== "secp256k1") {
              logger.throwArgumentError("unsupported curve; must be secp256k1", "privateKey", "[REDACTED]");
            }
            defineReadOnly(this, "_signingKey", () => privateKey);
          } else {
            if (typeof privateKey === "string") {
              if (privateKey.match(/^[0-9a-f]*$/i) && privateKey.length === 64) {
                privateKey = "0x" + privateKey;
              }
            }
            const signingKey = new SigningKey(privateKey);
            defineReadOnly(this, "_signingKey", () => signingKey);
          }
          defineReadOnly(this, "_mnemonic", () => null);
          defineReadOnly(this, "address", computeAddress(this.publicKey));
        }
        if (provider && !Provider.isProvider(provider)) {
          logger.throwArgumentError("invalid provider", "provider", provider);
        }
        defineReadOnly(this, "provider", provider || null);
      }
      get mnemonic() {
        return this._mnemonic();
      }
      get privateKey() {
        return this._signingKey().privateKey;
      }
      get publicKey() {
        return this._signingKey().publicKey;
      }
      getAddress() {
        return Promise.resolve(this.address);
      }
      connect(provider) {
        return new Wallet(this, provider);
      }
      signTransaction(transaction) {
        return resolveProperties(transaction).then((tx) => {
          if (tx.from != null) {
            if (getAddress(tx.from) !== this.address) {
              logger.throwArgumentError("transaction from address mismatch", "transaction.from", transaction.from);
            }
            delete tx.from;
          }
          const signature = this._signingKey().signDigest(keccak256(serialize(tx)));
          return serialize(tx, signature);
        });
      }
      signMessage(message) {
        return __awaiter(this, void 0, void 0, function* () {
          return joinSignature(this._signingKey().signDigest(hashMessage(message)));
        });
      }
      _signTypedData(domain, types, value) {
        return __awaiter(this, void 0, void 0, function* () {
          const populated = yield TypedDataEncoder.resolveNames(domain, types, value, (name) => {
            if (this.provider == null) {
              logger.throwError("cannot resolve ENS names without a provider", Logger.errors.UNSUPPORTED_OPERATION, {
                operation: "resolveName",
                value: name
              });
            }
            return this.provider.resolveName(name);
          });
          return joinSignature(this._signingKey().signDigest(TypedDataEncoder.hash(populated.domain, types, populated.value)));
        });
      }
      encrypt(password, options, progressCallback) {
        if (typeof options === "function" && !progressCallback) {
          progressCallback = options;
          options = {};
        }
        if (progressCallback && typeof progressCallback !== "function") {
          throw new Error("invalid callback");
        }
        if (!options) {
          options = {};
        }
        return encrypt(this, password, options, progressCallback);
      }
      static createRandom(options) {
        let entropy = randomBytes(16);
        if (!options) {
          options = {};
        }
        if (options.extraEntropy) {
          entropy = arrayify(hexDataSlice(keccak256(concat([entropy, options.extraEntropy])), 0, 16));
        }
        const mnemonic = entropyToMnemonic(entropy, options.locale);
        return Wallet.fromMnemonic(mnemonic, options.path, options.locale);
      }
      static fromEncryptedJson(json, password, progressCallback) {
        return decryptJsonWallet(json, password, progressCallback).then((account) => {
          return new Wallet(account);
        });
      }
      static fromEncryptedJsonSync(json, password) {
        return new Wallet(decryptJsonWalletSync(json, password));
      }
      static fromMnemonic(mnemonic, path, wordlist) {
        if (!path) {
          path = defaultPath;
        }
        return new Wallet(HDNode.fromMnemonic(mnemonic, null, wordlist).derivePath(path));
      }
    };
  }
});

// ../../node_modules/ethers/node_modules/@ethersproject/solidity/lib.esm/_version.js
var version2;
var init_version2 = __esm({
  "../../node_modules/ethers/node_modules/@ethersproject/solidity/lib.esm/_version.js"() {
    version2 = "solidity/5.7.0";
  }
});

// ../../node_modules/ethers/node_modules/@ethersproject/solidity/lib.esm/index.js
var lib_exports2 = {};
__export(lib_exports2, {
  keccak256: () => keccak2562,
  pack: () => pack,
  sha256: () => sha2562
});
function _pack(type, value, isArray) {
  switch (type) {
    case "address":
      if (isArray) {
        return zeroPad(value, 32);
      }
      return arrayify(value);
    case "string":
      return toUtf8Bytes(value);
    case "bytes":
      return arrayify(value);
    case "bool":
      value = value ? "0x01" : "0x00";
      if (isArray) {
        return zeroPad(value, 32);
      }
      return arrayify(value);
  }
  let match = type.match(regexNumber);
  if (match) {
    let size = parseInt(match[2] || "256");
    if (match[2] && String(size) !== match[2] || size % 8 !== 0 || size === 0 || size > 256) {
      logger2.throwArgumentError("invalid number type", "type", type);
    }
    if (isArray) {
      size = 256;
    }
    value = BigNumber.from(value).toTwos(size);
    return zeroPad(value, size / 8);
  }
  match = type.match(regexBytes);
  if (match) {
    const size = parseInt(match[1]);
    if (String(size) !== match[1] || size === 0 || size > 32) {
      logger2.throwArgumentError("invalid bytes type", "type", type);
    }
    if (arrayify(value).byteLength !== size) {
      logger2.throwArgumentError(`invalid value for ${type}`, "value", value);
    }
    if (isArray) {
      return arrayify((value + Zeros).substring(0, 66));
    }
    return value;
  }
  match = type.match(regexArray);
  if (match && Array.isArray(value)) {
    const baseType = match[1];
    const count = parseInt(match[2] || String(value.length));
    if (count != value.length) {
      logger2.throwArgumentError(`invalid array length for ${type}`, "value", value);
    }
    const result = [];
    value.forEach(function(value2) {
      result.push(_pack(baseType, value2, true));
    });
    return concat(result);
  }
  return logger2.throwArgumentError("invalid type", "type", type);
}
function pack(types, values) {
  if (types.length != values.length) {
    logger2.throwArgumentError("wrong number of values; expected ${ types.length }", "values", values);
  }
  const tight = [];
  types.forEach(function(type, index) {
    tight.push(_pack(type, values[index]));
  });
  return hexlify(concat(tight));
}
function keccak2562(types, values) {
  return keccak256(pack(types, values));
}
function sha2562(types, values) {
  return sha256(pack(types, values));
}
var regexBytes, regexNumber, regexArray, Zeros, logger2;
var init_lib18 = __esm({
  "../../node_modules/ethers/node_modules/@ethersproject/solidity/lib.esm/index.js"() {
    "use strict";
    init_lib3();
    init_lib2();
    init_lib5();
    init_lib13();
    init_lib7();
    init_lib();
    init_version2();
    regexBytes = new RegExp("^bytes([0-9]+)$");
    regexNumber = new RegExp("^(u?int)([0-9]*)$");
    regexArray = new RegExp("^(.*)\\[([0-9]*)\\]$");
    Zeros = "0000000000000000000000000000000000000000000000000000000000000000";
    logger2 = new Logger(version2);
  }
});

// ../../node_modules/ethers/node_modules/@ethersproject/units/lib.esm/_version.js
var version3;
var init_version3 = __esm({
  "../../node_modules/ethers/node_modules/@ethersproject/units/lib.esm/_version.js"() {
    version3 = "units/5.7.0";
  }
});

// ../../node_modules/ethers/node_modules/@ethersproject/units/lib.esm/index.js
var lib_exports3 = {};
__export(lib_exports3, {
  commify: () => commify,
  formatEther: () => formatEther,
  formatUnits: () => formatUnits,
  parseEther: () => parseEther,
  parseUnits: () => parseUnits
});
function commify(value) {
  const comps = String(value).split(".");
  if (comps.length > 2 || !comps[0].match(/^-?[0-9]*$/) || comps[1] && !comps[1].match(/^[0-9]*$/) || value === "." || value === "-.") {
    logger3.throwArgumentError("invalid value", "value", value);
  }
  let whole = comps[0];
  let negative = "";
  if (whole.substring(0, 1) === "-") {
    negative = "-";
    whole = whole.substring(1);
  }
  while (whole.substring(0, 1) === "0") {
    whole = whole.substring(1);
  }
  if (whole === "") {
    whole = "0";
  }
  let suffix = "";
  if (comps.length === 2) {
    suffix = "." + (comps[1] || "0");
  }
  while (suffix.length > 2 && suffix[suffix.length - 1] === "0") {
    suffix = suffix.substring(0, suffix.length - 1);
  }
  const formatted = [];
  while (whole.length) {
    if (whole.length <= 3) {
      formatted.unshift(whole);
      break;
    } else {
      const index = whole.length - 3;
      formatted.unshift(whole.substring(index));
      whole = whole.substring(0, index);
    }
  }
  return negative + formatted.join(",") + suffix;
}
function formatUnits(value, unitName) {
  if (typeof unitName === "string") {
    const index = names.indexOf(unitName);
    if (index !== -1) {
      unitName = 3 * index;
    }
  }
  return formatFixed(value, unitName != null ? unitName : 18);
}
function parseUnits(value, unitName) {
  if (typeof value !== "string") {
    logger3.throwArgumentError("value must be a string", "value", value);
  }
  if (typeof unitName === "string") {
    const index = names.indexOf(unitName);
    if (index !== -1) {
      unitName = 3 * index;
    }
  }
  return parseFixed(value, unitName != null ? unitName : 18);
}
function formatEther(wei) {
  return formatUnits(wei, 18);
}
function parseEther(ether) {
  return parseUnits(ether, 18);
}
var logger3, names;
var init_lib19 = __esm({
  "../../node_modules/ethers/node_modules/@ethersproject/units/lib.esm/index.js"() {
    "use strict";
    init_lib3();
    init_lib();
    init_version3();
    logger3 = new Logger(version3);
    names = [
      "wei",
      "kwei",
      "mwei",
      "gwei",
      "szabo",
      "finney",
      "ether"
    ];
  }
});

export {
  Wallet,
  verifyMessage,
  verifyTypedData,
  lib_exports,
  init_lib17 as init_lib,
  pack,
  keccak2562 as keccak256,
  sha2562 as sha256,
  lib_exports2,
  init_lib18 as init_lib2,
  commify,
  formatUnits,
  parseUnits,
  formatEther,
  parseEther,
  lib_exports3,
  init_lib19 as init_lib3
};
//# sourceMappingURL=chunk-IXUYKZNR.js.map
